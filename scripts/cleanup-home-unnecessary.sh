#!/bin/bash
# cleanup-home-unnecessary.sh - Remove auto-generated cache files and stale dotfiles
#
# Targets ONLY items that are safe to delete:
#   - Auto-regenerated cache files (zsh completion dumps)
#   - macOS metadata files (.DS_Store)
#   - Empty/stale tool directories no longer in use
#   - Broken symlinks to removed tools
#
# These items were identified by a manual HOME directory audit.
# None of them contain user data. All are either auto-regenerated
# by their respective tools or are empty remnants.
#
# Usage:
#   cleanup-home-unnecessary.sh              # Dry-run (default)
#   cleanup-home-unnecessary.sh --execute    # Actually delete
#   cleanup-home-unnecessary.sh --move-data  # Move .data/ to XDG location
#   cleanup-home-unnecessary.sh --execute --move-data  # Both
#
# Options:
#   --dry-run     (default) Show what would be deleted, change nothing
#   --execute     Actually delete the identified files
#   --move-data   Move .data/ to .local/share/data/
#   --help        Show this help message

set -euo pipefail

# ---------------------------------------------------------------------------
# Setup
# ---------------------------------------------------------------------------
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/lib.sh"

# ---------------------------------------------------------------------------
# Argument parsing
# ---------------------------------------------------------------------------
EXECUTE=false
MOVE_DATA=false

usage() {
    printf "Usage: %s [--execute] [--move-data] [--help]\n" "$(basename "$0")"
    printf "\n"
    printf "Remove auto-generated cache files and stale dotfiles from HOME.\n"
    printf "\n"
    printf "Options:\n"
    printf "  --dry-run     Show what would be deleted (default)\n"
    printf "  --execute     Actually delete the identified files\n"
    printf "  --move-data   Move .data/ to .local/share/data/\n"
    printf "  --help        Show this help message\n"
    exit 0
}

while [[ $# -gt 0 ]]; do
    case "$1" in
        --execute)    EXECUTE=true; shift ;;
        --dry-run)    EXECUTE=false; shift ;;
        --move-data)  MOVE_DATA=true; shift ;;
        --help|-h)    usage ;;
        *)
            log_error "Unknown option: $1"
            usage
            ;;
    esac
done

# ---------------------------------------------------------------------------
# Size utilities (macOS stat)
# ---------------------------------------------------------------------------
human_size() {
    local bytes="$1"
    if [[ $bytes -ge 1073741824 ]]; then
        printf "%.1fG" "$(echo "scale=1; $bytes / 1073741824" | bc)"
    elif [[ $bytes -ge 1048576 ]]; then
        printf "%.1fM" "$(echo "scale=1; $bytes / 1048576" | bc)"
    elif [[ $bytes -ge 1024 ]]; then
        printf "%.0fK" "$(echo "scale=0; $bytes / 1024" | bc)"
    else
        printf "%dB" "$bytes"
    fi
}

item_size_bytes() {
    local path="$1"
    if [[ -d "$path" ]]; then
        du -sk "$path" 2>/dev/null | awk '{print $1 * 1024}'
    elif [[ -f "$path" ]]; then
        stat -f%z "$path" 2>/dev/null || echo "0"
    elif [[ -L "$path" ]]; then
        # Broken symlink - size of the link itself
        echo "0"
    else
        echo "0"
    fi
}

# ---------------------------------------------------------------------------
# Define items to delete
#
# Each entry: path | reason why it's safe to delete
# ---------------------------------------------------------------------------
declare -a DELETE_PATHS=()
declare -a DELETE_REASONS=()
declare -a DELETE_SIZES=()

register_delete() {
    local path="$1"
    local reason="$2"

    # Only register if the item actually exists
    if [[ -e "$path" ]] || [[ -L "$path" ]]; then
        local size
        size="$(item_size_bytes "$path")"
        DELETE_PATHS+=("$path")
        DELETE_REASONS+=("$reason")
        DELETE_SIZES+=("$size")
    fi
}

# ---------------------------------------------------------------------------
# Phase 1: Discover items
# ---------------------------------------------------------------------------
discover_items() {
    # .zcompdump-* files: zsh completion cache
    # WHY SAFE: zsh regenerates these on next shell start via compinit.
    # They are pure cache - no user data, no configuration.
    while IFS= read -r -d '' file; do
        register_delete "$file" "zsh completion cache (auto-regenerated by compinit)"
    done < <(find "$HOME" -maxdepth 1 -name ".zcompdump*" -print0 2>/dev/null | sort -z)

    # .DS_Store: macOS Finder metadata
    # WHY SAFE: Created automatically by Finder whenever it opens a directory.
    # Contains only window positions and view preferences for that folder.
    register_delete "$HOME/.DS_Store" "macOS Finder metadata (auto-regenerated)"

    # .antigravity: Python easter egg cache directory
    # WHY SAFE: Created by Python's antigravity module (import antigravity).
    # Contains cached VS Code extension data, not user-created content.
    register_delete "$HOME/.antigravity" "Python antigravity cache directory"

    # .warp: Warp terminal config
    # WHY SAFE: Broken symlink pointing to iCloud mackup config that no longer exists.
    # Warp is not actively used.
    if [[ -L "$HOME/.warp" ]] && [[ ! -e "$HOME/.warp" ]]; then
        register_delete "$HOME/.warp" "broken symlink to removed Warp config"
    elif [[ -e "$HOME/.warp" ]]; then
        register_delete "$HOME/.warp" "stale Warp terminal config (not in use)"
    fi

    # .flutter: Flutter SDK settings
    # WHY SAFE: Contains a single small settings file. Flutter regenerates it
    # on next `flutter` command. No projects or user data stored here.
    register_delete "$HOME/.flutter" "Flutter SDK settings (auto-regenerated)"

    # .gemini: Google Gemini CLI directory
    # WHY SAFE: Empty directory (contains only an empty antigravity subdir).
    # No configuration or credentials stored.
    register_delete "$HOME/.gemini" "empty Gemini CLI directory"

    # .azure: Azure CLI config
    # WHY SAFE: Symlink to iCloud mackup config. Azure CLI recreates its config
    # directory on next `az` command. No active Azure usage.
    if [[ -L "$HOME/.azure" ]]; then
        register_delete "$HOME/.azure" "Azure CLI symlink (recreated by az on demand)"
    elif [[ -d "$HOME/.azure" ]]; then
        # Only delete if empty or near-empty
        local count
        count="$(find "$HOME/.azure" -mindepth 1 -maxdepth 1 2>/dev/null | wc -l | tr -d ' ')"
        if [[ "$count" -le 2 ]]; then
            register_delete "$HOME/.azure" "near-empty Azure CLI directory"
        fi
    fi

    # .aspnet: ASP.NET data protection keys
    # WHY SAFE: Symlink to .local/share/aspnet. If the symlink exists,
    # the data is already in the XDG location. The symlink is redundant.
    # ASP.NET regenerates keys as needed.
    if [[ -L "$HOME/.aspnet" ]]; then
        register_delete "$HOME/.aspnet" "redundant symlink (data already in .local/share)"
    elif [[ -d "$HOME/.aspnet" ]]; then
        local count
        count="$(find "$HOME/.aspnet" -mindepth 1 -maxdepth 1 2>/dev/null | wc -l | tr -d ' ')"
        if [[ "$count" -eq 0 ]]; then
            register_delete "$HOME/.aspnet" "empty ASP.NET directory"
        fi
    fi
}

# ---------------------------------------------------------------------------
# Phase 2: Display findings
# ---------------------------------------------------------------------------
display_findings() {
    local total_items="${#DELETE_PATHS[@]}"
    local total_bytes=0

    # Calculate total
    for size in "${DELETE_SIZES[@]}"; do
        total_bytes=$((total_bytes + size))
    done

    # Header
    printf "\n"
    printf "${BOLD}Home Cleanup - Unnecessary Files${NC}\n"
    printf "%s\n" "$(printf '%.0s=' {1..64})"
    printf "\n"

    if [[ $total_items -eq 0 ]] && [[ "$MOVE_DATA" != true || ! -d "$HOME/.data" ]]; then
        log_ok "Home directory is already clean. Nothing to do."
        exit 0
    fi

    # Delete section
    if [[ $total_items -gt 0 ]]; then
        printf "  ${BOLD}Items to DELETE (auto-generated / stale):${NC}\n\n"
        printf "  ${BOLD}%-45s %8s${NC}\n" "Path" "Size"
        printf "  %s\n" "$(printf '%.0s-' {1..54})"

        local i
        for i in "${!DELETE_PATHS[@]}"; do
            local path="${DELETE_PATHS[$i]}"
            local reason="${DELETE_REASONS[$i]}"
            local size="${DELETE_SIZES[$i]}"
            local name
            name="$(basename "$path")"
            local size_human
            size_human="$(human_size "$size")"

            # Show type indicator
            local type_indicator=""
            if [[ -L "$path" ]]; then
                type_indicator=" (symlink)"
            elif [[ -d "$path" ]]; then
                type_indicator="/"
            fi

            printf "  ${RED}%-45s %8s${NC}\n" "${name}${type_indicator}" "$size_human"
            printf "  ${BLUE}  %s${NC}\n" "$reason"
        done

        printf "  %s\n" "$(printf '%.0s-' {1..54})"
        printf "  ${BOLD}%-45s %8s${NC}\n" "Total to delete ($total_items items)" "$(human_size "$total_bytes")"
        printf "  ${BLUE}  All items are auto-regenerated or stale${NC}\n"
    fi

    # Move section
    if [[ "$MOVE_DATA" == true ]] && [[ -d "$HOME/.data" ]]; then
        local data_size
        data_size="$(item_size_bytes "$HOME/.data")"
        local data_human
        data_human="$(human_size "$data_size")"

        printf "\n"
        printf "  ${BOLD}Items to MOVE:${NC}\n\n"
        printf "  ${YELLOW}%-30s --> %-25s %8s${NC}\n" ".data/" ".local/share/data/" "$data_human"
    fi

    printf "\n"
}

# ---------------------------------------------------------------------------
# Phase 3: Execute deletions
# ---------------------------------------------------------------------------
execute_deletions() {
    local deleted=0
    local failed=0
    local skipped=0

    printf "\n"
    log_header "Executing Deletions"

    for i in "${!DELETE_PATHS[@]}"; do
        local path="${DELETE_PATHS[$i]}"
        local path_short="${path/#$HOME/~}"

        # Idempotency: skip if already gone
        if [[ ! -e "$path" ]] && [[ ! -L "$path" ]]; then
            log_info "Already gone: $path_short"
            skipped=$((skipped + 1))
            continue
        fi

        # Delete (rm -rf handles files, dirs, and symlinks)
        if rm -rf "$path" 2>/dev/null; then
            log_ok "Deleted: $path_short"
            deleted=$((deleted + 1))
        else
            log_error "Failed to delete: $path_short"
            failed=$((failed + 1))
        fi
    done

    printf "\n"
    printf "  ${BOLD}Results:${NC} ${GREEN}%d deleted${NC}" "$deleted"
    if [[ $skipped -gt 0 ]]; then
        printf "  ${BLUE}%d already clean${NC}" "$skipped"
    fi
    if [[ $failed -gt 0 ]]; then
        printf "  ${RED}%d failed${NC}" "$failed"
    fi
    printf "\n"
}

# ---------------------------------------------------------------------------
# Phase 4: Move .data/ to XDG location
# ---------------------------------------------------------------------------
execute_move_data() {
    if [[ "$MOVE_DATA" != true ]]; then
        return 0
    fi

    if [[ ! -d "$HOME/.data" ]]; then
        log_info ".data/ does not exist - nothing to move"
        return 0
    fi

    local target_dir="$XDG_DATA_HOME/data"

    printf "\n"
    log_header "Moving .data/ to XDG location"

    # Check if target already exists
    if [[ -d "$target_dir" ]]; then
        log_error "Target already exists: ${target_dir/#$HOME/~}"
        log_error "Merge manually or remove the target first."
        return 1
    fi

    if [[ "$EXECUTE" != true ]]; then
        log_info "Would move: ~/.data/ --> ${target_dir/#$HOME/~}/"
        return 0
    fi

    # Ensure parent directory exists
    ensure_parent_dir "$target_dir"

    # Move the directory
    if mv "$HOME/.data" "$target_dir" 2>/dev/null; then
        log_ok "Moved: ~/.data/ --> ${target_dir/#$HOME/~}/"
        log_info "Applications using ~/.data/ may need path updates"
    else
        log_error "Failed to move .data/"
        return 1
    fi
}

# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------
main() {
    # Phase 1: Discover
    discover_items

    # Phase 2: Display
    display_findings

    # Dry-run summary
    if [[ "$EXECUTE" != true ]]; then
        printf "%s\n" "$(printf '%.0s=' {1..64})"
        printf "  ${BOLD}Status:${NC} ${BLUE}DRY-RUN - no changes made${NC}\n"
        printf "\n"
        printf "  ${BOLD}Next:${NC}\n"
        printf "    %s --execute              ${BLUE}# Delete the items above${NC}\n" "$(basename "$0")"
        if [[ -d "$HOME/.data" ]]; then
            printf "    %s --execute --move-data  ${BLUE}# Delete + move .data/${NC}\n" "$(basename "$0")"
        fi
        printf "\n"

        # Show move-data preview if requested
        execute_move_data
        exit 0
    fi

    # Execute mode
    printf "%s\n" "$(printf '%.0s=' {1..64})"

    if [[ "$EXECUTE" == true ]]; then
        printf "  ${YELLOW}MODE: EXECUTE - changes will be made${NC}\n"
    fi

    # Phase 3: Delete
    if [[ ${#DELETE_PATHS[@]} -gt 0 ]]; then
        execute_deletions
    fi

    # Phase 4: Move .data/
    execute_move_data

    # Final summary
    printf "\n"
    printf "%s\n" "$(printf '%.0s=' {1..64})"
    log_ok "Home cleanup complete."
    printf "\n"
}

main
